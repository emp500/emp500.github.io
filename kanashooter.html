<!DOCTYPE html>
<html>
    <head>
        <title>Kana Training Game</title>
        <meta charset="UTF-8">
        <style>
            body {
                background-color: lightblue;
            }
            canvas {
                position: absolute;
                top: 0;
                left: 0;
            }

            .wrapper {
                position: relative;
                width: 1280px;
                height: 720px;
             }

            .wrapper canvas {
                position: absolute;
                top: 0;
                left: 0;
            }
        </style>
        <script src="charsets/hiragana.js"></script>
        <script src="charsets/katakana.js"></script>
        <script>
            // Class: Player
            // Contains the location of the player character and drawing function
            class Player {
                constructor(location) {
                    this.location = location;
                }

                draw(c) {
                    drawRegularPolygon(c, this.location, 5, 3, "#00FF00", -Math.PI/2);
                }
            }
            
            // Class: Bullet
            // These are the bullets the player fires
            class Bullet {
                constructor(location, velocity) {
                    this.location = location;
                    this.oldLocation = subtractVectors(location, velocity);
                    this.destroyed = false;
                    this.fired = false; // If the bullet is fired, set to true. We want to hear the laser sound only once
                }

                draw(c) {
                    drawBullet(c, this.location, subtractVectors(this.location, this.oldLocation));

                    // Play firing sound once when drawn
                    if (!this.fired) {
                        let laserSound = new Audio("laser3.mp3");
                        laserSound.loop = false;

                        laserSound.play();

                        this.fired = true;
                    }
                    
                }

                checkForHit(enemy) {
                    if (calculateDistance(enemy.location, this.location) <= enemy.radius) {
                        return true;
                    }
                    else {
                        return false;
                    }
                }
            }

            // Class: Enemy
            // These are the enemies falling down
            class Enemy {
                constructor(location, velocity) {
                    this.location = location;
                    this.oldLocation = subtractVectors(location, velocity);
                    this.kana = pickRandomCharacter(CURRENT_CHARSET);
                    this.radius = 20;
                    this.sides = 4;

                    this.destroyed = false;
                    this.hitTaken = false;

                }

                draw(c) {
                    let ctx = c.getContext("2d");
                    ctx.font = "30px Arial";
                    ctx.fillStyle = "white";
                    ctx.textAlign = "center";
                    
                    ctx.fillText(`${this.kana.jp}`, this.location[0], this.location[1]);
                }

                playHitSound() {
                    // Play destroyed sound when... destroyed.
                    let destroyedSound = new Audio("pepSound5.mp3");
                        destroyedSound.loop = false;
                        destroyedSound.play();
                }
            }

            
            function pickRandomCharacter(kana) {
                return kana[Math.floor(Math.random() * kana.length)];
            }

            // Add two vectors
            function addVectors(v, u) {
                return [ v[0] + u[0], v[1] + u[1] ];
            }

            // Substract two vectors
            function subtractVectors(v, u) {
                return [ v[0] - u[0], v[1] - u[1] ];
            }

            // Calculate the Euclidean distance between two vectors
            // d = sqrt((x-x0)^2+(y-y0)`2)
            function calculateDistance(v, u) {
                return Math.sqrt(Math.pow((v[0] - u[0]),2) + Math.pow((v[1] - u[1]),2));
            }

            
            // draw a bullet originating from location with the speed of velocity
            function drawBullet(canvas, location, velocity) {
                var ctx = canvas.getContext("2d");
                ctx.strokeStyle = "#FFFFFF";
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(location[0], location[1]);
                ctx.lineTo(location[0] + velocity[0], location[1] + velocity[1]);
                ctx.stroke();
            }

            
            // Draw score on canvas
            // Includes combo and ammo as well
            function drawScore(c, isGameOver=false) {
                let ctx = c.getContext("2d");
                ctx.font = "32px Arial";
                if (isGameOver) {
                    ctx.fillStyle = "red";
                    ctx.textAlign = "center";
                    ctx.fillText(`GAME OVER! Final score: ${SCORE}. Press H for Hiragana, K for Katakana`, CANVAS_SIZE[0]/2, CANVAS_SIZE[1]/2);
                }
                else {
                    ctx.fillStyle = "white";
                    ctx.textAlign = "left";
                    if (COMBO > 1) {
                        ctx.fillText(`Score: ${SCORE} (x${COMBO} COMBO!!)`, 0, 32);
                    }
                    else {
                        ctx.fillText(`Score: ${SCORE}`, 0, 32);
                    } 
                }
            }

            // canvas size [x, y]. Remember to change wrapper too. (css)
            var CANVAS_SIZE = [1280, 720];

            // main function, executed on body load
            function main() {
                // init text input
                USERINPUT = document.getElementById("kanaInput");
                // initialize main canvas
                let c = initCanvas("canvas", CANVAS_SIZE[0], CANVAS_SIZE[1]);
                // initialize scrolling background canvas
                let bgCanvas = initCanvas("bgCanvas", CANVAS_SIZE[0], CANVAS_SIZE[1]);
                
                
                
                // scroll background
                var ctx = bgCanvas.getContext("2d");
                var bgImg = new Image();
                bgImg.src = "space.png";

                bgImg.onload = function() {
                    
                    var imgHeight = 0;
                    var scrollSpeed = 5;

                    function loop() {
                        if (INTERVAL !== null) {
                            // Move background image up, but also draw another one below -> Creates a scrolling effect
                            ctx.drawImage(bgImg, 0, imgHeight);
                            ctx.drawImage(bgImg, 0, imgHeight - bgCanvas.height);
                            imgHeight += scrollSpeed;
                            
                            // Reset when fully scrolled
                            if (imgHeight == bgCanvas.height) {
                                imgHeight = 0;
                            }
                        }
                        
                        // let's make the loop... loop by requesting animation frame
                        window.requestAnimationFrame(loop);
                    }

                    loop();
                }
                 // scroll bg end


                // start actual simulation
                startSimulation(c);
            }

            // Array for enemies
            var ENEMIES=[];
            // Array for bullets
            var BULLETS=[];
            // Player location
            var PLAYER = new Player([CANVAS_SIZE[0]/2, CANVAS_SIZE[1] - 50]);
            
            // how many times is the simulation being done in a second (Hz)
            var SIMULATION_RATE = 30;
            // Score
            var SCORE = 0;
            
            // Current combo
            var COMBO = 0;
            
            // the interval is stored in this variable
            var INTERVAL = null;

            let LOOPS = 0;

            var USERINPUT = null;

            var ENABLE_AUTO_ERASE = true;

            var CURRENT_CHARSET = hiragana;

            var isGameOver = true;

            // simulation logic, most the action happens here
            function startSimulation(c) {
                let ctx = c.getContext("2d");
                ctx.font = "32px Arial";
                ctx.fillStyle = "red";
                ctx.textAlign = "center";
                ctx.fillText(`Write H for Hiragana, K for Katakana`, CANVAS_SIZE[0]/2, CANVAS_SIZE[1]/2);

                USERINPUT.focus();

                INTERVAL = setInterval(function() {
                    if (!isGameOver) {
                        if (ENABLE_AUTO_ERASE && USERINPUT.value.length > 3) {
                            USERINPUT.value = "";
                        }
                        // Clear the canvas
                        clearCanvas(c);
                        // Draw current score
                        drawScore(c);

                        // Draw player character on screen
                        PLAYER.draw(c);

                        // Generate ENEMIES
                        // Add new enemy every N iteration of the interval loop
                        if (LOOPS > (50*(1/(SCORE===0)?1:SCORE))) {
                            ENEMIES.push(new Enemy([rng(20, CANVAS_SIZE[0]-20),0], [0,rng(2, 6)]));
                            LOOPS = 0;
                        }
                        LOOPS++;
                    
                        // Calculate new locations to ENEMIES
                        for (let i = 0; i < ENEMIES.length; ++i) {
                            if (!ENEMIES[i].destroyed && !ENEMIES[i].hitTaken && USERINPUT.value === ENEMIES[i].kana.ro) {
                                PLAYER.location = [ENEMIES[i].location[0], PLAYER.location[1]];
                                BULLETS.push(new Bullet(PLAYER.location, [0, -10]));
                                USERINPUT.value = "";
                                ENEMIES[i].hitTaken = true;
                            }
                            // If the enemy ship is not destroyed, move it
                            if (!ENEMIES[i].destroyed) {
                                // Get the new location
                                let velocity = subtractVectors(ENEMIES[i].location, ENEMIES[i].oldLocation);
                                let newLoc = addVectors(ENEMIES[i].location, velocity);

                                // Update old location and new location variables
                                ENEMIES[i].oldLocation = ENEMIES[i].location;
                                ENEMIES[i].location = newLoc;

                                // Draw the enemy on the canvas
                                ENEMIES[i].draw(c);

                                // If the enemy gets to the bottom of the screen
                                // it's game over
                                if ((ENEMIES[i].location[1] >= CANVAS_SIZE[1])) {
                                    clearCanvas(c);
                                    drawScore(c, true);
                                    isGameOver = true;
                                    //clearInterval(INTERVAL);
                                    //INTERVAL = null;
                                    ENEMIES = [];
                                    BULLETS = [];
                                    SCORE = 0;
                                    COMBO = 0;
                                }
                            }
                        }

                        // Calculate new locations to BULLETS
                        for (let i = 0; i < BULLETS.length; ++i) {
                            // Get the new location
                            let velocity = subtractVectors(BULLETS[i].location, BULLETS[i].oldLocation);
                            let newLoc = addVectors(BULLETS[i].location, velocity);

                            // Update old location and new location variables
                            BULLETS[i].oldLocation = BULLETS[i].location;
                            BULLETS[i].location = newLoc;

                            // Draw the bullet on the canvas
                            BULLETS[i].draw(c);

                            // Hit detection, if a hit is detected, mark bullet and enemy as destroyed
                            for (let j = 0; j < ENEMIES.length; j++) {
                                if (ENEMIES[j] !== undefined && BULLETS[i] !== undefined && !BULLETS[i].destroyed && !ENEMIES[j].destroyed && ENEMIES[j].hitTaken && BULLETS[i].checkForHit(ENEMIES[j])) {
                                        BULLETS[i].destroyed = true;
                                        ENEMIES[j].destroyed = true;
                                        SCORE += 10;

                                        COMBO += 1; // get combo for a hit
                                }
                            }
                        }

                        // Remove destroyed enemies
                        for (let i = 0; i < ENEMIES.length; ++i) {
                            if (ENEMIES[i].destroyed) {
                                ENEMIES[i].playHitSound();
                                ENEMIES.splice(i, 1); 
                            }
                            // Remove enemies when they are too far off screen
                            else if (ENEMIES[i].location[1] < 0 || ENEMIES[i].location > CANVAS_SIZE[1]) {
                                ENEMIES.splice(i, 1);
                            }
                        }

                        // Remove destroyed bullets
                        for (let i = 0; i < BULLETS.length; ++i) {
                            if (BULLETS[i].destroyed) {
                                BULLETS.splice(i, 1);
                            }
                            // Remove bullets when they are too far off screen
                            else if (BULLETS[i].location[1] < 0 || BULLETS[i].location[1] > CANVAS_SIZE[1]) {
                                BULLETS.splice(i, 1);
                                COMBO = 0;
                            }
                        }

                    }
                    else {
                        if (USERINPUT.value === "H" || USERINPUT.value === "h") {
                            CURRENT_CHARSET = hiragana;
                            USERINPUT.value = "";
                            isGameOver = false;
                        }               
                        else if (USERINPUT.value === "K" || USERINPUT.value === "k") {
                            CURRENT_CHARSET = katakana;
                            USERINPUT.value = "";
                            isGameOver = false;
                        }
                    }
                },1000/SIMULATION_RATE);
            }

            // random number generator
            function rng(min, max) {
                return Math.random() * (max - min) + min;
            }

            // clear canvas
            function clearCanvas(canvas){
				var ctx = canvas.getContext("2d");
				ctx.clearRect(0,0,CANVAS_SIZE[0],CANVAS_SIZE[1]);
			}

            // initialize canvas with selected width and height
            function initCanvas(canvasID, width, height) {
                let c = document.getElementById(canvasID);
                let ctx = c.getContext("2d");
                c.setAttribute("width",width+"px");
                c.setAttribute("height",height+"px");
                ctx.canvas.width = width;
                ctx.canvas.height = height;
                return c;
            }

            // draw polygon
            // goes through unit circle
            function drawRegularPolygon(canvas, location, radius, sides, color=null, rotation=0) {
				var ctx = canvas.getContext("2d");
                
                // Random color if no color is given (Flashing every update)
                if (color === null) {
                    let r = rng(0, 255);
                    let g = rng(0, 255);
                    let b = rng(0, 255);

                    let strokeStyleString = 'rgb(' + r + ', ' + g + ', ' + b + ')';
                    ctx.strokeStyle = strokeStyleString;
                }
                else {
                    ctx.strokeStyle = color;
                }
                
                ctx.lineWidth = 2;
				ctx.beginPath();
				var x=location[0]+Math.cos(0+rotation)*radius;
				var y=location[1]+Math.sin(0+rotation)*radius;
				ctx.moveTo(x, y);
				sides/=2;
				for(var i=Math.PI/sides;i<=Math.PI*2;i+=Math.PI/sides){
					var x=location[0]+Math.cos(i+rotation)*radius;
					var y=location[1]+Math.sin(i+rotation)*radius;
					ctx.lineTo(x, y);
				}
				var x=location[0]+Math.cos(0+rotation)*radius;
				var y=location[1]+Math.sin(0+rotation)*radius;
				ctx.lineTo(x, y);
				
				ctx.stroke();
			}

        </script>
    </head>
    <body onload="main()">
        <h1>Kana Training Game</h1><hr>
        <div class="wrapper" id="wrapper">
            <canvas id="bgCanvas"></canvas>
            <canvas id="canvas"></canvas>
        </div>
        <p>Enter your answer:</p><input type="text" id="kanaInput" tabindex="1"/>
        <hr>
        <p>SOUND EFFECTS SOURCE: <a href="https://opengameart.org/content/63-digital-sound-effects-lasers-phasers-space-etc">opengameart.org - Kenney.nl</a></p>
    </body>
</html>
